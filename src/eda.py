# -*- coding: utf-8 -*-
"""EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FDSo4SxD5WIhcGaEhY1SJesQfekIfvaa
"""



"""**Import Libraries and Data**"""

!pip install skimpy

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from skimpy import clean_columns

import warnings
warnings.filterwarnings("ignore")
warnings.warn("this will not show")

plt.rcParams["figure.figsize"] = (10,6)

sns.set_style("whitegrid")
pd.set_option('display.float_format', lambda x: '%.3f' % x)

# Set it None to display all rows in the dataframe
# pd.set_option('display.max_rows', None)

# Set it to None to display all columns in the dataframe
pd.set_option('display.max_columns', None)

df = pd.read_csv("/content/cleaned_data.csv")

# Overview of the Data
print("DataFrame Shape:", df.shape)
print("Data Types:\n", df.dtypes)

# Summary Statistics
summary_statistics = df.describe()
print("Summary Statistics:\n", summary_statistics)

import matplotlib.pyplot as plt
import seaborn as sns

# Visualizing the distribution of numerical features
numerical_features = df.select_dtypes(include=['float64', 'int64']).columns

plt.figure(figsize=(12, 10))
for i, feature in enumerate(numerical_features, 1):
    plt.subplot(3, 3, i)  # Adjust the number of rows and columns based on features
    sns.histplot(df[feature], bins=30, kde=True)
    plt.title(f'Distribution of {feature}')
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
import os

# Create a directory to save the images if it doesn't exist
output_dir = 'plots'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Select categorical features
categorical_features = df.select_dtypes(include=['object', 'bool']).columns

# Set batch size and number of columns for subplots
batch_size = 10
num_cols = 3

# Randomly sample data if the dataset is large (e.g., 10,000 rows)
sample_size = min(10000, len(df))  # Limit to 10,000 rows
df_sample = df.sample(sample_size)

# Loop through categorical features in batches
for i in range(0, len(categorical_features), batch_size):
    batch_features = categorical_features[i:i + batch_size]
    num_rows = (len(batch_features) + num_cols - 1) // num_cols  # Calculate rows needed

    fig, axes = plt.subplots(num_rows, num_cols, figsize=(12, 5 * num_rows))
    axes = axes.flatten()

    for j, feature in enumerate(batch_features):
        sns.countplot(data=df_sample, x=feature, ax=axes[j])
        axes[j].set_title(f'Distribution of {feature}')
        axes[j].tick_params(axis='x', rotation=45)

    # Hide unused subplots if the batch is smaller than the grid size
    for k in range(j + 1, num_rows * num_cols):
        fig.delaxes(axes[k])

    plt.tight_layout()

    # Save the figure as an image
    save_path = os.path.join(output_dir, f'categorical_distribution_batch_{i//batch_size + 1}.png')
    plt.savefig(save_path)  # Save the figure
    plt.close()  # Close the figure to free memory

# Correlation Analysis
correlation_matrix = df_encoded[numerical_features].corr()
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()

# Identifying Missing Values
missing_values = df_encoded.isnull().sum()
print("Missing Values:\n", missing_values[missing_values > 0])

# Outlier Detection using box plots
plt.figure(figsize=(12, 10))
for i, feature in enumerate(numerical_features, 1):
    plt.subplot(3, 3, i)  # Adjust the number of rows and columns based on features
    sns.boxplot(x=df_encoded[feature])
    plt.title(f'Box Plot of {feature}')
plt.tight_layout()
plt.show()

"""# Feature Engineering"""

# Create Aggregate Features
agg_features = df_encoded.groupby('CustomerId').agg(
    Total_Transaction_Amount=('log_amount', 'sum'),
    Average_Transaction_Amount=('log_amount', 'mean'),
    Transaction_Count=('log_amount', 'count'),
    Std_Transaction_Amount=('log_amount', 'std')
).reset_index()

# Merging back with the original DataFrame if needed
df_encoded = df_encoded.merge(agg_features, on='CustomerId', how='left')